# Arquitetura Completa - RÃ©gua de EstratÃ©gias com IA

## 1. VisÃ£o Geral do Sistema

### Objetivos:
- âœ… **CriaÃ§Ã£o Manual**: Interface visual drag & drop
- ðŸŽ¯ **CriaÃ§Ã£o por IA**: ConversaÃ§Ã£o natural para gerar estratÃ©gias
- ðŸ”„ **HÃ­brido**: Combinar criaÃ§Ã£o manual com sugestÃµes de IA
- ðŸ“Š **IntegraÃ§Ã£o**: Usar dados existentes do CRM para personalizaÃ§Ã£o

### Fluxo de CriaÃ§Ã£o por IA:
\`\`\`
UsuÃ¡rio: "Quero criar uma estratÃ©gia de prospecÃ§Ã£o B2B"
    â†“
IA: Analisa intenÃ§Ã£o + contexto do cliente
    â†“
IA: "Entendi! Vou criar uma estratÃ©gia de prospecÃ§Ã£o. Algumas perguntas:
     - Qual a fonte dos leads? (planilha, banco, API)
     - Quantos dias de follow-up vocÃª quer?
     - Prefere comeÃ§ar com email ou WhatsApp?"
    â†“
UsuÃ¡rio: Responde perguntas
    â†“
IA: Gera estrutura da estratÃ©gia automaticamente
    â†“
Sistema: Salva e permite ediÃ§Ã£o manual se necessÃ¡rio
\`\`\`

## 2. Componentes da Arquitetura

### 2.1 Backend APIs (Existente + Novo)
\`\`\`
/api/strategies/                    # CRUD bÃ¡sico
/api/strategies/ai/                 # Endpoints especÃ­ficos para IA
â”œâ”€â”€ /analyze-intent                 # Analisar intenÃ§Ã£o do usuÃ¡rio
â”œâ”€â”€ /generate-strategy              # Gerar estratÃ©gia completa
â”œâ”€â”€ /suggest-nodes                  # Sugerir nÃ³s baseado no contexto
â”œâ”€â”€ /validate-strategy              # Validar estratÃ©gia gerada
â””â”€â”€ /complete-missing               # Identificar campos obrigatÃ³rios
\`\`\`

### 2.2 IA Strategy Builder (Novo)
\`\`\`
StrategyAI/
â”œâ”€â”€ IntentAnalyzer                  # Analisa o que o usuÃ¡rio quer
â”œâ”€â”€ ContextExtractor                # Extrai contexto do cliente/CRM
â”œâ”€â”€ StrategyGenerator               # Gera estrutura da estratÃ©gia
â”œâ”€â”€ NodeSuggester                   # Sugere nÃ³s apropriados
â”œâ”€â”€ ConversationManager             # Gerencia diÃ¡logo com usuÃ¡rio
â””â”€â”€ ValidationEngine                # Valida estratÃ©gia gerada
\`\`\`

### 2.3 IntegraÃ§Ã£o com Chat Existente
\`\`\`
ChatSystem (Existente)
â”œâ”€â”€ MessageProcessor               # Processa mensagens
â”œâ”€â”€ APIConnector                   # Conecta com APIs de dados
â””â”€â”€ StrategyModule (Novo)          # MÃ³dulo especÃ­fico para estratÃ©gias
    â”œâ”€â”€ StrategyIntentDetector     # Detecta quando falar de estratÃ©gias
    â”œâ”€â”€ StrategyConversation       # Gerencia conversa sobre estratÃ©gias
    â””â”€â”€ StrategyExecutor           # Executa criaÃ§Ã£o da estratÃ©gia
\`\`\`

## 3. Estrutura de Dados para IA

### 3.1 Intent Classification
\`\`\`json
{
  "intents": {
    "create_strategy": {
      "keywords": ["estratÃ©gia", "rÃ©gua", "automaÃ§Ã£o", "sequÃªncia"],
      "patterns": [
        "quero criar uma estratÃ©gia",
        "preciso automatizar",
        "fazer uma rÃ©gua de",
        "sequÃªncia de contatos"
      ]
    },
    "strategy_types": {
      "prospeccao": ["prospecÃ§Ã£o", "leads", "vendas", "contatos"],
      "customer_success": ["retenÃ§Ã£o", "clientes", "satisfaÃ§Ã£o"],
      "cobranca": ["cobranÃ§a", "pagamento", "inadimplÃªncia"]
    }
  }
}
\`\`\`

### 3.2 Strategy Templates por IA
\`\`\`json
{
  "templates": {
    "prospeccao_b2b": {
      "name": "ProspecÃ§Ã£o B2B",
      "description": "EstratÃ©gia padrÃ£o para prospecÃ§Ã£o B2B",
      "questions": [
        {
          "id": "data_source",
          "question": "Qual a fonte dos seus leads?",
          "options": ["planilha", "banco_dados", "api_externa", "manual"],
          "required": true
        },
        {
          "id": "timeline_days",
          "question": "Quantos dias de follow-up vocÃª quer?",
          "type": "number",
          "default": 30,
          "required": true
        },
        {
          "id": "first_contact",
          "question": "Como prefere fazer o primeiro contato?",
          "options": ["email", "whatsapp", "linkedin", "telefone"],
          "required": true
        }
      ],
      "node_templates": {
        "workflow": [
          {
            "condition": "data_source == 'planilha'",
            "node": {
              "type": "data-import",
              "title": "Importar Planilha",
              "day": -999,
              "config": {
                "webhook": "{{webhook_import}}"
              }
            }
          }
        ],
        "timeline": [
          {
            "condition": "first_contact == 'email'",
            "node": {
              "type": "send-email",
              "title": "Email Inicial",
              "day": 0,
              "config": {
                "subject": "{{email_subject}}",
                "body": "{{email_body}}"
              }
            }
          }
        ]
      }
    }
  }
}
\`\`\`

### 3.3 Context Data Structure
\`\`\`json
{
  "client_context": {
    "client_id": 1,
    "industry": "tecnologia",
    "company_size": "startup",
    "current_strategies": 3,
    "active_leads": 150,
    "conversion_rate": 0.12,
    "preferred_channels": ["email", "whatsapp"],
    "integrations": ["n8n", "make", "zapier"]
  },
  "user_context": {
    "user_id": 1,
    "role": "vendedor",
    "experience_level": "intermediario",
    "created_strategies": 5,
    "preferred_templates": ["prospeccao", "followup"]
  }
}
\`\`\`

## 4. Fluxos de ConversaÃ§Ã£o

### 4.1 DetecÃ§Ã£o de IntenÃ§Ã£o
\`\`\`javascript
// Exemplo de detecÃ§Ã£o
const message = "Quero criar uma estratÃ©gia para prospecÃ§Ã£o"

const intent = await StrategyAI.analyzeIntent(message, clientContext)
// Resultado:
{
  "intent": "create_strategy",
  "strategy_type": "prospeccao",
  "confidence": 0.95,
  "entities": {
    "action": "criar",
    "type": "estratÃ©gia",
    "purpose": "prospecÃ§Ã£o"
  }
}
\`\`\`

### 4.2 GeraÃ§Ã£o de Perguntas
\`\`\`javascript
const questions = await StrategyAI.generateQuestions(intent, clientContext)
// Resultado:
[
  {
    "id": "data_source",
    "question": "Qual serÃ¡ a fonte dos seus leads para esta estratÃ©gia?",
    "type": "multiple_choice",
    "options": [
      { "value": "planilha", "label": "Importar de planilha Excel/CSV" },
      { "value": "banco", "label": "Consultar banco de dados" },
      { "value": "api", "label": "IntegraÃ§Ã£o com API externa" }
    ],
    "required": true
  },
  {
    "id": "timeline",
    "question": "Quantos dias de follow-up vocÃª gostaria?",
    "type": "number",
    "min": 1,
    "max": 365,
    "default": 30,
    "required": true
  }
]
\`\`\`

### 4.3 GeraÃ§Ã£o da EstratÃ©gia
\`\`\`javascript
const answers = {
  "data_source": "planilha",
  "timeline": 15,
  "first_contact": "email",
  "followup_channels": ["whatsapp", "email"]
}

const strategy = await StrategyAI.generateStrategy(intent, answers, clientContext)
// Resultado: estrutura completa da estratÃ©gia
\`\`\`

## 5. ImplementaÃ§Ã£o Backend

### 5.1 Strategy AI Controller
\`\`\`javascript
class StrategyAIController {
  // Analisar intenÃ§Ã£o do usuÃ¡rio
  async analyzeIntent(req, res) {
    const { message, context } = req.body
    const intent = await IntentAnalyzer.analyze(message, context)
    res.json({ intent })
  }

  // Gerar perguntas baseadas na intenÃ§Ã£o
  async generateQuestions(req, res) {
    const { intent, clientContext } = req.body
    const questions = await QuestionGenerator.generate(intent, clientContext)
    res.json({ questions })
  }

  // Gerar estratÃ©gia completa
  async generateStrategy(req, res) {
    const { intent, answers, clientContext } = req.body
    const strategy = await StrategyGenerator.generate(intent, answers, clientContext)
    res.json({ strategy })
  }

  // Sugerir melhorias em estratÃ©gia existente
  async suggestImprovements(req, res) {
    const { strategyId } = req.params
    const suggestions = await ImprovementSuggester.analyze(strategyId)
    res.json({ suggestions })
  }
}
\`\`\`

### 5.2 Intent Analyzer
\`\`\`javascript
class IntentAnalyzer {
  static async analyze(message, context) {
    // 1. Preprocessar mensagem
    const cleanMessage = this.preprocess(message)
    
    // 2. Detectar intenÃ§Ã£o principal
    const intent = await this.detectIntent(cleanMessage)
    
    // 3. Extrair entidades
    const entities = await this.extractEntities(cleanMessage)
    
    // 4. Determinar tipo de estratÃ©gia
    const strategyType = await this.determineStrategyType(entities, context)
    
    return {
      intent,
      strategyType,
      entities,
      confidence: this.calculateConfidence(intent, entities)
    }
  }

  static detectIntent(message) {
    const intents = {
      'create_strategy': [
        /criar.*estratÃ©gia/i,
        /nova.*rÃ©gua/i,
        /automatizar.*processo/i,
        /sequÃªncia.*contatos/i
      ],
      'modify_strategy': [
        /alterar.*estratÃ©gia/i,
        /modificar.*rÃ©gua/i,
        /editar.*automaÃ§Ã£o/i
      ],
      'analyze_strategy': [
        /analisar.*estratÃ©gia/i,
        /performance.*rÃ©gua/i,
        /resultados.*automaÃ§Ã£o/i
      ]
    }

    for (const [intent, patterns] of Object.entries(intents)) {
      if (patterns.some(pattern => pattern.test(message))) {
        return intent
      }
    }

    return 'unknown'
  }
}
\`\`\`

### 5.3 Strategy Generator
\`\`\`javascript
class StrategyGenerator {
  static async generate(intent, answers, clientContext) {
    // 1. Selecionar template base
    const template = await this.selectTemplate(intent.strategyType, clientContext)
    
    // 2. Processar respostas
    const processedAnswers = this.processAnswers(answers, template)
    
    // 3. Gerar workflow nodes
    const workflowNodes = await this.generateWorkflowNodes(template, processedAnswers)
    
    // 4. Gerar timeline nodes
    const timelineNodes = await this.generateTimelineNodes(template, processedAnswers)
    
    // 5. Calcular timeline days
    const timelineDays = this.calculateTimelineDays(processedAnswers)
    
    return {
      name: this.generateStrategyName(intent, processedAnswers),
      description: this.generateDescription(intent, processedAnswers),
      dataInicial: new Date().toISOString().split('T')[0],
      diasUteis: processedAnswers.business_days || false,
      timelineDays,
      workflowNodes,
      timelineNodes,
      isActive: true,
      aiGenerated: true,
      template: template.id
    }
  }

  static generateWorkflowNodes(template, answers) {
    const nodes = []
    
    // Processar cada template de nÃ³
    template.node_templates.workflow.forEach((nodeTemplate, index) => {
      if (this.evaluateCondition(nodeTemplate.condition, answers)) {
        const node = {
          id: `workflow-ai-${Date.now()}-${index}`,
          type: nodeTemplate.node.type,
          title: this.processTemplate(nodeTemplate.node.title, answers),
          day: -999,
          position: { x: 100 + (index * 200), y: 100 },
          config: this.processConfig(nodeTemplate.node.config, answers)
        }
        nodes.push(node)
      }
    })
    
    return nodes
  }

  static generateTimelineNodes(template, answers) {
    const nodes = []
    let dayIndex = 0
    
    template.node_templates.timeline.forEach((nodeTemplate, index) => {
      if (this.evaluateCondition(nodeTemplate.condition, answers)) {
        const node = {
          id: `timeline-ai-${Date.now()}-${index}`,
          type: nodeTemplate.node.type,
          title: this.processTemplate(nodeTemplate.node.title, answers),
          day: nodeTemplate.node.day || dayIndex,
          position: { x: 50, y: 50 + (index * 80) },
          config: this.processConfig(nodeTemplate.node.config, answers)
        }
        nodes.push(node)
        dayIndex += 2 // EspaÃ§ar dias
      }
    })
    
    return nodes
  }
}
\`\`\`

## 6. IntegraÃ§Ã£o com Chat Existente

### 6.1 Strategy Chat Module
\`\`\`javascript
class StrategyChatModule {
  constructor(chatSystem) {
    this.chatSystem = chatSystem
    this.activeConversations = new Map()
  }

  async processMessage(message, userId, clientId) {
    // 1. Verificar se Ã© sobre estratÃ©gias
    if (!this.isStrategyRelated(message)) {
      return null // Deixa outros mÃ³dulos processarem
    }

    // 2. Obter ou criar conversa ativa
    const conversation = this.getOrCreateConversation(userId)

    // 3. Processar mensagem no contexto da conversa
    const response = await this.processStrategyMessage(message, conversation, clientId)

    // 4. Atualizar estado da conversa
    this.updateConversation(userId, conversation)

    return response
  }

  async processStrategyMessage(message, conversation, clientId) {
    const context = await this.getClientContext(clientId)

    switch (conversation.state) {
      case 'initial':
        return await this.handleInitialMessage(message, conversation, context)
      
      case 'collecting_requirements':
        return await this.handleRequirementCollection(message, conversation, context)
      
      case 'generating_strategy':
        return await this.handleStrategyGeneration(message, conversation, context)
      
      case 'reviewing_strategy':
        return await this.handleStrategyReview(message, conversation, context)
      
      default:
        return this.handleUnknownState(conversation)
    }
  }

  async handleInitialMessage(message, conversation, context) {
    // Analisar intenÃ§Ã£o
    const intent = await StrategyAI.analyzeIntent(message, context)
    
    if (intent.intent === 'create_strategy') {
      // Gerar perguntas iniciais
      const questions = await StrategyAI.generateQuestions(intent, context)
      
      conversation.state = 'collecting_requirements'
      conversation.intent = intent
      conversation.questions = questions
      conversation.currentQuestionIndex = 0
      
      return {
        message: `Perfeito! Vou te ajudar a criar uma estratÃ©gia de ${intent.strategyType}. 
                 ${questions[0].question}`,
        options: questions[0].options || null,
        type: 'question'
      }
    }
    
    return {
      message: "NÃ£o entendi sua solicitaÃ§Ã£o sobre estratÃ©gias. Pode reformular?",
      type: 'clarification'
    }
  }

  async handleRequirementCollection(message, conversation, context) {
    const currentQuestion = conversation.questions[conversation.currentQuestionIndex]
    
    // Salvar resposta
    conversation.answers = conversation.answers || {}
    conversation.answers[currentQuestion.id] = this.parseAnswer(message, currentQuestion)
    
    // PrÃ³xima pergunta ou gerar estratÃ©gia
    conversation.currentQuestionIndex++
    
    if (conversation.currentQuestionIndex < conversation.questions.length) {
      const nextQuestion = conversation.questions[conversation.currentQuestionIndex]
      return {
        message: nextQuestion.question,
        options: nextQuestion.options || null,
        type: 'question'
      }
    } else {
      // Todas as perguntas respondidas, gerar estratÃ©gia
      conversation.state = 'generating_strategy'
      
      const strategy = await StrategyAI.generateStrategy(
        conversation.intent,
        conversation.answers,
        context
      )
      
      conversation.generatedStrategy = strategy
      conversation.state = 'reviewing_strategy'
      
      return {
        message: `Ã“timo! Criei sua estratÃ©gia "${strategy.name}". 
                 Ela tem ${strategy.workflowNodes.length} nÃ³s no workflow geral e 
                 ${strategy.timelineNodes.length} nÃ³s na timeline.
                 
                 Quer que eu salve essa estratÃ©gia ou prefere fazer algum ajuste?`,
        strategy: strategy,
        type: 'strategy_preview',
        actions: ['salvar', 'ajustar', 'cancelar']
      }
    }
  }
}
\`\`\`

## 7. PrÃ³ximos Passos de ImplementaÃ§Ã£o

### Fase 1: Backend BÃ¡sico (1-2 semanas)
- [ ] Implementar CRUD completo das estratÃ©gias
- [ ] Criar estrutura de templates
- [ ] Implementar validaÃ§Ãµes bÃ¡sicas

### Fase 2: IA Foundation (2-3 semanas)
- [ ] Intent Analyzer bÃ¡sico
- [ ] Question Generator
- [ ] Strategy Generator simples
- [ ] IntegraÃ§Ã£o com chat existente

### Fase 3: IA AvanÃ§ada (3-4 semanas)
- [ ] Machine Learning para melhor detecÃ§Ã£o
- [ ] Context-aware suggestions
- [ ] Aprendizado com feedback do usuÃ¡rio
- [ ] Templates dinÃ¢micos

### Fase 4: ExecuÃ§Ã£o Real (2-3 semanas)
- [ ] Webhook execution engine
- [ ] IntegraÃ§Ã£o com N8N/Make
- [ ] Monitoring e logs avanÃ§ados
- [ ] Error handling e retry logic

## 8. ConsideraÃ§Ãµes TÃ©cnicas

### Performance:
- Cache de templates e contexto
- Processamento assÃ­ncrono de IA
- Rate limiting para APIs de IA

### SeguranÃ§a:
- ValidaÃ§Ã£o de inputs de IA
- SanitizaÃ§Ã£o de webhooks gerados
- Auditoria de estratÃ©gias criadas por IA

### Escalabilidade:
- MicroserviÃ§os para IA
- Queue system para processamento
- Database sharding por cliente

### Monitoramento:
- MÃ©tricas de uso da IA
- Accuracy das sugestÃµes
- Performance dos templates
